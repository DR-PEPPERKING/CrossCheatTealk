// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CrossCheatTalkNetMessages.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "CrossCheatTalkNetMessages.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google::protobuf::Descriptor* ConnectionAcceptedMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ConnectionAcceptedMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* ChatMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ChatMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* SharedESPVector_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SharedESPVector_reflection_ = NULL;
const ::google::protobuf::Descriptor* SharedEspPlayerData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SharedEspPlayerData_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* SharedEspPlayerData_StandardizedPlayerDataFlags_descriptor_ = NULL;
const ::google::protobuf::Descriptor* StandardizedSharedESP_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  StandardizedSharedESP_reflection_ = NULL;
const ::google::protobuf::Descriptor* StandardizedCheatInformation_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  StandardizedCheatInformation_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* CrossCheatMsgType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_CrossCheatTalkNetMessages_2eproto() {
  protobuf_AddDesc_CrossCheatTalkNetMessages_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "CrossCheatTalkNetMessages.proto");
  GOOGLE_CHECK(file != NULL);
  ConnectionAcceptedMessage_descriptor_ = file->message_type(0);
  static const int ConnectionAcceptedMessage_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConnectionAcceptedMessage, sender_steamid_),
  };
  ConnectionAcceptedMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ConnectionAcceptedMessage_descriptor_,
      ConnectionAcceptedMessage::default_instance_,
      ConnectionAcceptedMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConnectionAcceptedMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConnectionAcceptedMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ConnectionAcceptedMessage));
  ChatMessage_descriptor_ = file->message_type(1);
  static const int ChatMessage_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChatMessage, sender_steamid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChatMessage, message_),
  };
  ChatMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ChatMessage_descriptor_,
      ChatMessage::default_instance_,
      ChatMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChatMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChatMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ChatMessage));
  SharedESPVector_descriptor_ = file->message_type(2);
  static const int SharedESPVector_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SharedESPVector, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SharedESPVector, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SharedESPVector, z_),
  };
  SharedESPVector_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SharedESPVector_descriptor_,
      SharedESPVector::default_instance_,
      SharedESPVector_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SharedESPVector, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SharedESPVector, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SharedESPVector));
  SharedEspPlayerData_descriptor_ = file->message_type(3);
  static const int SharedEspPlayerData_offsets_[10] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SharedEspPlayerData, player_user_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SharedEspPlayerData, player_steam_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SharedEspPlayerData, player_origin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SharedEspPlayerData, player_health_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SharedEspPlayerData, player_armor_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SharedEspPlayerData, player_bbmin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SharedEspPlayerData, player_bbmax_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SharedEspPlayerData, player_active_weapon_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SharedEspPlayerData, player_ammo_count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SharedEspPlayerData, player_clip_size_),
  };
  SharedEspPlayerData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SharedEspPlayerData_descriptor_,
      SharedEspPlayerData::default_instance_,
      SharedEspPlayerData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SharedEspPlayerData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SharedEspPlayerData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SharedEspPlayerData));
  SharedEspPlayerData_StandardizedPlayerDataFlags_descriptor_ = SharedEspPlayerData_descriptor_->enum_type(0);
  StandardizedSharedESP_descriptor_ = file->message_type(4);
  static const int StandardizedSharedESP_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StandardizedSharedESP, sender_steamid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StandardizedSharedESP, message_send_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StandardizedSharedESP, player_data_),
  };
  StandardizedSharedESP_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      StandardizedSharedESP_descriptor_,
      StandardizedSharedESP::default_instance_,
      StandardizedSharedESP_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StandardizedSharedESP, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StandardizedSharedESP, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(StandardizedSharedESP));
  StandardizedCheatInformation_descriptor_ = file->message_type(5);
  static const int StandardizedCheatInformation_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StandardizedCheatInformation, sender_steamid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StandardizedCheatInformation, cheat_name_),
  };
  StandardizedCheatInformation_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      StandardizedCheatInformation_descriptor_,
      StandardizedCheatInformation::default_instance_,
      StandardizedCheatInformation_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StandardizedCheatInformation, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StandardizedCheatInformation, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(StandardizedCheatInformation));
  CrossCheatMsgType_descriptor_ = file->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_CrossCheatTalkNetMessages_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ConnectionAcceptedMessage_descriptor_, &ConnectionAcceptedMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ChatMessage_descriptor_, &ChatMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SharedESPVector_descriptor_, &SharedESPVector::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SharedEspPlayerData_descriptor_, &SharedEspPlayerData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    StandardizedSharedESP_descriptor_, &StandardizedSharedESP::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    StandardizedCheatInformation_descriptor_, &StandardizedCheatInformation::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_CrossCheatTalkNetMessages_2eproto() {
  delete ConnectionAcceptedMessage::default_instance_;
  delete ConnectionAcceptedMessage_reflection_;
  delete ChatMessage::default_instance_;
  delete ChatMessage_reflection_;
  delete SharedESPVector::default_instance_;
  delete SharedESPVector_reflection_;
  delete SharedEspPlayerData::default_instance_;
  delete SharedEspPlayerData_reflection_;
  delete StandardizedSharedESP::default_instance_;
  delete StandardizedSharedESP_reflection_;
  delete StandardizedCheatInformation::default_instance_;
  delete StandardizedCheatInformation_reflection_;
}

void protobuf_AddDesc_CrossCheatTalkNetMessages_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\037CrossCheatTalkNetMessages.proto\"3\n\031Con"
    "nectionAcceptedMessage\022\026\n\016sender_steamid"
    "\030\001 \002(\r\"6\n\013ChatMessage\022\026\n\016sender_steamid\030"
    "\001 \002(\r\022\017\n\007message\030\002 \002(\t\"2\n\017SharedESPVecto"
    "r\022\t\n\001x\030\001 \002(\002\022\t\n\001y\030\002 \002(\002\022\t\n\001z\030\003 \002(\002\"\256\003\n\023S"
    "haredEspPlayerData\022\026\n\016player_user_id\030\002 \002"
    "(\r\022\027\n\017player_steam_id\030\003 \002(\r\022\'\n\rplayer_or"
    "igin\030\004 \002(\0132\020.SharedESPVector\022\025\n\rplayer_h"
    "ealth\030\005 \001(\005\022\024\n\014player_armor\030\006 \001(\005\022&\n\014pla"
    "yer_bbmin\030\007 \001(\0132\020.SharedESPVector\022&\n\014pla"
    "yer_bbmax\030\010 \001(\0132\020.SharedESPVector\022\034\n\024pla"
    "yer_active_weapon\030\t \001(\005\022\031\n\021player_ammo_c"
    "ount\030\n \001(\005\022\030\n\020player_clip_size\030\013 \001(\005\"m\n\033"
    "StandardizedPlayerDataFlags\022\n\n\006SCOPED\020\001\022"
    "\014\n\010DEFUSING\020\002\022\013\n\007FLASHED\020\003\022\n\n\006HAS_C4\020\004\022\r"
    "\n\tRELOADING\020\005\022\014\n\010PLANTING\020\006\"u\n\025Standardi"
    "zedSharedESP\022\026\n\016sender_steamid\030\001 \002(\r\022\031\n\021"
    "message_send_time\030\002 \002(\002\022)\n\013player_data\030\003"
    " \003(\0132\024.SharedEspPlayerData\"J\n\034Standardiz"
    "edCheatInformation\022\026\n\016sender_steamid\030\001 \002"
    "(\r\022\022\n\ncheat_name\030\002 \001(\t*}\n\021CrossCheatMsgT"
    "ype\022\027\n\023_ConnectionAccepted\020\000\022\020\n\014_ChatMes"
    "sage\020\001\022\032\n\026_StandardizedSharedESP\020\002\022!\n\035_S"
    "tandardizedCheatInformation\020\003", 949);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "CrossCheatTalkNetMessages.proto", &protobuf_RegisterTypes);
  ConnectionAcceptedMessage::default_instance_ = new ConnectionAcceptedMessage();
  ChatMessage::default_instance_ = new ChatMessage();
  SharedESPVector::default_instance_ = new SharedESPVector();
  SharedEspPlayerData::default_instance_ = new SharedEspPlayerData();
  StandardizedSharedESP::default_instance_ = new StandardizedSharedESP();
  StandardizedCheatInformation::default_instance_ = new StandardizedCheatInformation();
  ConnectionAcceptedMessage::default_instance_->InitAsDefaultInstance();
  ChatMessage::default_instance_->InitAsDefaultInstance();
  SharedESPVector::default_instance_->InitAsDefaultInstance();
  SharedEspPlayerData::default_instance_->InitAsDefaultInstance();
  StandardizedSharedESP::default_instance_->InitAsDefaultInstance();
  StandardizedCheatInformation::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_CrossCheatTalkNetMessages_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_CrossCheatTalkNetMessages_2eproto {
  StaticDescriptorInitializer_CrossCheatTalkNetMessages_2eproto() {
    protobuf_AddDesc_CrossCheatTalkNetMessages_2eproto();
  }
} static_descriptor_initializer_CrossCheatTalkNetMessages_2eproto_;
const ::google::protobuf::EnumDescriptor* CrossCheatMsgType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CrossCheatMsgType_descriptor_;
}
bool CrossCheatMsgType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int ConnectionAcceptedMessage::kSenderSteamidFieldNumber;
#endif  // !_MSC_VER

ConnectionAcceptedMessage::ConnectionAcceptedMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ConnectionAcceptedMessage::InitAsDefaultInstance() {
}

ConnectionAcceptedMessage::ConnectionAcceptedMessage(const ConnectionAcceptedMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ConnectionAcceptedMessage::SharedCtor() {
  _cached_size_ = 0;
  sender_steamid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ConnectionAcceptedMessage::~ConnectionAcceptedMessage() {
  SharedDtor();
}

void ConnectionAcceptedMessage::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ConnectionAcceptedMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ConnectionAcceptedMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ConnectionAcceptedMessage_descriptor_;
}

const ConnectionAcceptedMessage& ConnectionAcceptedMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CrossCheatTalkNetMessages_2eproto();
  return *default_instance_;
}

ConnectionAcceptedMessage* ConnectionAcceptedMessage::default_instance_ = NULL;

ConnectionAcceptedMessage* ConnectionAcceptedMessage::New() const {
  return new ConnectionAcceptedMessage;
}

void ConnectionAcceptedMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    sender_steamid_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ConnectionAcceptedMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 sender_steamid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sender_steamid_)));
          set_has_sender_steamid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ConnectionAcceptedMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 sender_steamid = 1;
  if (has_sender_steamid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->sender_steamid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ConnectionAcceptedMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 sender_steamid = 1;
  if (has_sender_steamid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->sender_steamid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ConnectionAcceptedMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 sender_steamid = 1;
    if (has_sender_steamid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sender_steamid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ConnectionAcceptedMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ConnectionAcceptedMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ConnectionAcceptedMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ConnectionAcceptedMessage::MergeFrom(const ConnectionAcceptedMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sender_steamid()) {
      set_sender_steamid(from.sender_steamid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ConnectionAcceptedMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ConnectionAcceptedMessage::CopyFrom(const ConnectionAcceptedMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectionAcceptedMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ConnectionAcceptedMessage::Swap(ConnectionAcceptedMessage* other) {
  if (other != this) {
    std::swap(sender_steamid_, other->sender_steamid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ConnectionAcceptedMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ConnectionAcceptedMessage_descriptor_;
  metadata.reflection = ConnectionAcceptedMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ChatMessage::kSenderSteamidFieldNumber;
const int ChatMessage::kMessageFieldNumber;
#endif  // !_MSC_VER

ChatMessage::ChatMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ChatMessage::InitAsDefaultInstance() {
}

ChatMessage::ChatMessage(const ChatMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ChatMessage::SharedCtor() {
  _cached_size_ = 0;
  sender_steamid_ = 0u;
  message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChatMessage::~ChatMessage() {
  SharedDtor();
}

void ChatMessage::SharedDtor() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (this != default_instance_) {
  }
}

void ChatMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ChatMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ChatMessage_descriptor_;
}

const ChatMessage& ChatMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CrossCheatTalkNetMessages_2eproto();
  return *default_instance_;
}

ChatMessage* ChatMessage::default_instance_ = NULL;

ChatMessage* ChatMessage::New() const {
  return new ChatMessage;
}

void ChatMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    sender_steamid_ = 0u;
    if (has_message()) {
      if (message_ != &::google::protobuf::internal::kEmptyString) {
        message_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ChatMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 sender_steamid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sender_steamid_)));
          set_has_sender_steamid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_message;
        break;
      }

      // required string message = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->message().data(), this->message().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ChatMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 sender_steamid = 1;
  if (has_sender_steamid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->sender_steamid(), output);
  }

  // required string message = 2;
  if (has_message()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->message(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ChatMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 sender_steamid = 1;
  if (has_sender_steamid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->sender_steamid(), target);
  }

  // required string message = 2;
  if (has_message()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->message(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ChatMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 sender_steamid = 1;
    if (has_sender_steamid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sender_steamid());
    }

    // required string message = 2;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->message());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChatMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ChatMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ChatMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ChatMessage::MergeFrom(const ChatMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sender_steamid()) {
      set_sender_steamid(from.sender_steamid());
    }
    if (from.has_message()) {
      set_message(from.message());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ChatMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ChatMessage::CopyFrom(const ChatMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChatMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void ChatMessage::Swap(ChatMessage* other) {
  if (other != this) {
    std::swap(sender_steamid_, other->sender_steamid_);
    std::swap(message_, other->message_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ChatMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ChatMessage_descriptor_;
  metadata.reflection = ChatMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SharedESPVector::kXFieldNumber;
const int SharedESPVector::kYFieldNumber;
const int SharedESPVector::kZFieldNumber;
#endif  // !_MSC_VER

SharedESPVector::SharedESPVector()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SharedESPVector::InitAsDefaultInstance() {
}

SharedESPVector::SharedESPVector(const SharedESPVector& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SharedESPVector::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  z_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SharedESPVector::~SharedESPVector() {
  SharedDtor();
}

void SharedESPVector::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SharedESPVector::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SharedESPVector::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SharedESPVector_descriptor_;
}

const SharedESPVector& SharedESPVector::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CrossCheatTalkNetMessages_2eproto();
  return *default_instance_;
}

SharedESPVector* SharedESPVector::default_instance_ = NULL;

SharedESPVector* SharedESPVector::New() const {
  return new SharedESPVector;
}

void SharedESPVector::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    x_ = 0;
    y_ = 0;
    z_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SharedESPVector::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float x = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_y;
        break;
      }

      // required float y = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_z;
        break;
      }

      // required float z = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SharedESPVector::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }

  // required float y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }

  // required float z = 3;
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->z(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SharedESPVector::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->x(), target);
  }

  // required float y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->y(), target);
  }

  // required float z = 3;
  if (has_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->z(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SharedESPVector::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float x = 1;
    if (has_x()) {
      total_size += 1 + 4;
    }

    // required float y = 2;
    if (has_y()) {
      total_size += 1 + 4;
    }

    // required float z = 3;
    if (has_z()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SharedESPVector::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SharedESPVector* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SharedESPVector*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SharedESPVector::MergeFrom(const SharedESPVector& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SharedESPVector::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SharedESPVector::CopyFrom(const SharedESPVector& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SharedESPVector::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void SharedESPVector::Swap(SharedESPVector* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(z_, other->z_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SharedESPVector::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SharedESPVector_descriptor_;
  metadata.reflection = SharedESPVector_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* SharedEspPlayerData_StandardizedPlayerDataFlags_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SharedEspPlayerData_StandardizedPlayerDataFlags_descriptor_;
}
bool SharedEspPlayerData_StandardizedPlayerDataFlags_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const SharedEspPlayerData_StandardizedPlayerDataFlags SharedEspPlayerData::SCOPED;
const SharedEspPlayerData_StandardizedPlayerDataFlags SharedEspPlayerData::DEFUSING;
const SharedEspPlayerData_StandardizedPlayerDataFlags SharedEspPlayerData::FLASHED;
const SharedEspPlayerData_StandardizedPlayerDataFlags SharedEspPlayerData::HAS_C4;
const SharedEspPlayerData_StandardizedPlayerDataFlags SharedEspPlayerData::RELOADING;
const SharedEspPlayerData_StandardizedPlayerDataFlags SharedEspPlayerData::PLANTING;
const SharedEspPlayerData_StandardizedPlayerDataFlags SharedEspPlayerData::StandardizedPlayerDataFlags_MIN;
const SharedEspPlayerData_StandardizedPlayerDataFlags SharedEspPlayerData::StandardizedPlayerDataFlags_MAX;
const int SharedEspPlayerData::StandardizedPlayerDataFlags_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int SharedEspPlayerData::kPlayerUserIdFieldNumber;
const int SharedEspPlayerData::kPlayerSteamIdFieldNumber;
const int SharedEspPlayerData::kPlayerOriginFieldNumber;
const int SharedEspPlayerData::kPlayerHealthFieldNumber;
const int SharedEspPlayerData::kPlayerArmorFieldNumber;
const int SharedEspPlayerData::kPlayerBbminFieldNumber;
const int SharedEspPlayerData::kPlayerBbmaxFieldNumber;
const int SharedEspPlayerData::kPlayerActiveWeaponFieldNumber;
const int SharedEspPlayerData::kPlayerAmmoCountFieldNumber;
const int SharedEspPlayerData::kPlayerClipSizeFieldNumber;
#endif  // !_MSC_VER

SharedEspPlayerData::SharedEspPlayerData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SharedEspPlayerData::InitAsDefaultInstance() {
  player_origin_ = const_cast< ::SharedESPVector*>(&::SharedESPVector::default_instance());
  player_bbmin_ = const_cast< ::SharedESPVector*>(&::SharedESPVector::default_instance());
  player_bbmax_ = const_cast< ::SharedESPVector*>(&::SharedESPVector::default_instance());
}

SharedEspPlayerData::SharedEspPlayerData(const SharedEspPlayerData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SharedEspPlayerData::SharedCtor() {
  _cached_size_ = 0;
  player_user_id_ = 0u;
  player_steam_id_ = 0u;
  player_origin_ = NULL;
  player_health_ = 0;
  player_armor_ = 0;
  player_bbmin_ = NULL;
  player_bbmax_ = NULL;
  player_active_weapon_ = 0;
  player_ammo_count_ = 0;
  player_clip_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SharedEspPlayerData::~SharedEspPlayerData() {
  SharedDtor();
}

void SharedEspPlayerData::SharedDtor() {
  if (this != default_instance_) {
    delete player_origin_;
    delete player_bbmin_;
    delete player_bbmax_;
  }
}

void SharedEspPlayerData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SharedEspPlayerData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SharedEspPlayerData_descriptor_;
}

const SharedEspPlayerData& SharedEspPlayerData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CrossCheatTalkNetMessages_2eproto();
  return *default_instance_;
}

SharedEspPlayerData* SharedEspPlayerData::default_instance_ = NULL;

SharedEspPlayerData* SharedEspPlayerData::New() const {
  return new SharedEspPlayerData;
}

void SharedEspPlayerData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    player_user_id_ = 0u;
    player_steam_id_ = 0u;
    if (has_player_origin()) {
      if (player_origin_ != NULL) player_origin_->::SharedESPVector::Clear();
    }
    player_health_ = 0;
    player_armor_ = 0;
    if (has_player_bbmin()) {
      if (player_bbmin_ != NULL) player_bbmin_->::SharedESPVector::Clear();
    }
    if (has_player_bbmax()) {
      if (player_bbmax_ != NULL) player_bbmax_->::SharedESPVector::Clear();
    }
    player_active_weapon_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    player_ammo_count_ = 0;
    player_clip_size_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SharedEspPlayerData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 player_user_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &player_user_id_)));
          set_has_player_user_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_player_steam_id;
        break;
      }

      // required uint32 player_steam_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_player_steam_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &player_steam_id_)));
          set_has_player_steam_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_player_origin;
        break;
      }

      // required .SharedESPVector player_origin = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_player_origin:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_player_origin()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_player_health;
        break;
      }

      // optional int32 player_health = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_player_health:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &player_health_)));
          set_has_player_health();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_player_armor;
        break;
      }

      // optional int32 player_armor = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_player_armor:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &player_armor_)));
          set_has_player_armor();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_player_bbmin;
        break;
      }

      // optional .SharedESPVector player_bbmin = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_player_bbmin:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_player_bbmin()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_player_bbmax;
        break;
      }

      // optional .SharedESPVector player_bbmax = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_player_bbmax:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_player_bbmax()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_player_active_weapon;
        break;
      }

      // optional int32 player_active_weapon = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_player_active_weapon:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &player_active_weapon_)));
          set_has_player_active_weapon();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_player_ammo_count;
        break;
      }

      // optional int32 player_ammo_count = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_player_ammo_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &player_ammo_count_)));
          set_has_player_ammo_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_player_clip_size;
        break;
      }

      // optional int32 player_clip_size = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_player_clip_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &player_clip_size_)));
          set_has_player_clip_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SharedEspPlayerData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 player_user_id = 2;
  if (has_player_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->player_user_id(), output);
  }

  // required uint32 player_steam_id = 3;
  if (has_player_steam_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->player_steam_id(), output);
  }

  // required .SharedESPVector player_origin = 4;
  if (has_player_origin()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->player_origin(), output);
  }

  // optional int32 player_health = 5;
  if (has_player_health()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->player_health(), output);
  }

  // optional int32 player_armor = 6;
  if (has_player_armor()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->player_armor(), output);
  }

  // optional .SharedESPVector player_bbmin = 7;
  if (has_player_bbmin()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->player_bbmin(), output);
  }

  // optional .SharedESPVector player_bbmax = 8;
  if (has_player_bbmax()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->player_bbmax(), output);
  }

  // optional int32 player_active_weapon = 9;
  if (has_player_active_weapon()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->player_active_weapon(), output);
  }

  // optional int32 player_ammo_count = 10;
  if (has_player_ammo_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->player_ammo_count(), output);
  }

  // optional int32 player_clip_size = 11;
  if (has_player_clip_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(11, this->player_clip_size(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SharedEspPlayerData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 player_user_id = 2;
  if (has_player_user_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->player_user_id(), target);
  }

  // required uint32 player_steam_id = 3;
  if (has_player_steam_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->player_steam_id(), target);
  }

  // required .SharedESPVector player_origin = 4;
  if (has_player_origin()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->player_origin(), target);
  }

  // optional int32 player_health = 5;
  if (has_player_health()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->player_health(), target);
  }

  // optional int32 player_armor = 6;
  if (has_player_armor()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->player_armor(), target);
  }

  // optional .SharedESPVector player_bbmin = 7;
  if (has_player_bbmin()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->player_bbmin(), target);
  }

  // optional .SharedESPVector player_bbmax = 8;
  if (has_player_bbmax()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->player_bbmax(), target);
  }

  // optional int32 player_active_weapon = 9;
  if (has_player_active_weapon()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(9, this->player_active_weapon(), target);
  }

  // optional int32 player_ammo_count = 10;
  if (has_player_ammo_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(10, this->player_ammo_count(), target);
  }

  // optional int32 player_clip_size = 11;
  if (has_player_clip_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(11, this->player_clip_size(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SharedEspPlayerData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 player_user_id = 2;
    if (has_player_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->player_user_id());
    }

    // required uint32 player_steam_id = 3;
    if (has_player_steam_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->player_steam_id());
    }

    // required .SharedESPVector player_origin = 4;
    if (has_player_origin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->player_origin());
    }

    // optional int32 player_health = 5;
    if (has_player_health()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->player_health());
    }

    // optional int32 player_armor = 6;
    if (has_player_armor()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->player_armor());
    }

    // optional .SharedESPVector player_bbmin = 7;
    if (has_player_bbmin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->player_bbmin());
    }

    // optional .SharedESPVector player_bbmax = 8;
    if (has_player_bbmax()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->player_bbmax());
    }

    // optional int32 player_active_weapon = 9;
    if (has_player_active_weapon()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->player_active_weapon());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional int32 player_ammo_count = 10;
    if (has_player_ammo_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->player_ammo_count());
    }

    // optional int32 player_clip_size = 11;
    if (has_player_clip_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->player_clip_size());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SharedEspPlayerData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SharedEspPlayerData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SharedEspPlayerData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SharedEspPlayerData::MergeFrom(const SharedEspPlayerData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_player_user_id()) {
      set_player_user_id(from.player_user_id());
    }
    if (from.has_player_steam_id()) {
      set_player_steam_id(from.player_steam_id());
    }
    if (from.has_player_origin()) {
      mutable_player_origin()->::SharedESPVector::MergeFrom(from.player_origin());
    }
    if (from.has_player_health()) {
      set_player_health(from.player_health());
    }
    if (from.has_player_armor()) {
      set_player_armor(from.player_armor());
    }
    if (from.has_player_bbmin()) {
      mutable_player_bbmin()->::SharedESPVector::MergeFrom(from.player_bbmin());
    }
    if (from.has_player_bbmax()) {
      mutable_player_bbmax()->::SharedESPVector::MergeFrom(from.player_bbmax());
    }
    if (from.has_player_active_weapon()) {
      set_player_active_weapon(from.player_active_weapon());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_player_ammo_count()) {
      set_player_ammo_count(from.player_ammo_count());
    }
    if (from.has_player_clip_size()) {
      set_player_clip_size(from.player_clip_size());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SharedEspPlayerData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SharedEspPlayerData::CopyFrom(const SharedEspPlayerData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SharedEspPlayerData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_player_origin()) {
    if (!this->player_origin().IsInitialized()) return false;
  }
  if (has_player_bbmin()) {
    if (!this->player_bbmin().IsInitialized()) return false;
  }
  if (has_player_bbmax()) {
    if (!this->player_bbmax().IsInitialized()) return false;
  }
  return true;
}

void SharedEspPlayerData::Swap(SharedEspPlayerData* other) {
  if (other != this) {
    std::swap(player_user_id_, other->player_user_id_);
    std::swap(player_steam_id_, other->player_steam_id_);
    std::swap(player_origin_, other->player_origin_);
    std::swap(player_health_, other->player_health_);
    std::swap(player_armor_, other->player_armor_);
    std::swap(player_bbmin_, other->player_bbmin_);
    std::swap(player_bbmax_, other->player_bbmax_);
    std::swap(player_active_weapon_, other->player_active_weapon_);
    std::swap(player_ammo_count_, other->player_ammo_count_);
    std::swap(player_clip_size_, other->player_clip_size_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SharedEspPlayerData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SharedEspPlayerData_descriptor_;
  metadata.reflection = SharedEspPlayerData_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int StandardizedSharedESP::kSenderSteamidFieldNumber;
const int StandardizedSharedESP::kMessageSendTimeFieldNumber;
const int StandardizedSharedESP::kPlayerDataFieldNumber;
#endif  // !_MSC_VER

StandardizedSharedESP::StandardizedSharedESP()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void StandardizedSharedESP::InitAsDefaultInstance() {
}

StandardizedSharedESP::StandardizedSharedESP(const StandardizedSharedESP& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void StandardizedSharedESP::SharedCtor() {
  _cached_size_ = 0;
  sender_steamid_ = 0u;
  message_send_time_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StandardizedSharedESP::~StandardizedSharedESP() {
  SharedDtor();
}

void StandardizedSharedESP::SharedDtor() {
  if (this != default_instance_) {
  }
}

void StandardizedSharedESP::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StandardizedSharedESP::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StandardizedSharedESP_descriptor_;
}

const StandardizedSharedESP& StandardizedSharedESP::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CrossCheatTalkNetMessages_2eproto();
  return *default_instance_;
}

StandardizedSharedESP* StandardizedSharedESP::default_instance_ = NULL;

StandardizedSharedESP* StandardizedSharedESP::New() const {
  return new StandardizedSharedESP;
}

void StandardizedSharedESP::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    sender_steamid_ = 0u;
    message_send_time_ = 0;
  }
  player_data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool StandardizedSharedESP::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 sender_steamid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sender_steamid_)));
          set_has_sender_steamid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_message_send_time;
        break;
      }

      // required float message_send_time = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_message_send_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &message_send_time_)));
          set_has_message_send_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_player_data;
        break;
      }

      // repeated .SharedEspPlayerData player_data = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_player_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_player_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_player_data;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void StandardizedSharedESP::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 sender_steamid = 1;
  if (has_sender_steamid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->sender_steamid(), output);
  }

  // required float message_send_time = 2;
  if (has_message_send_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->message_send_time(), output);
  }

  // repeated .SharedEspPlayerData player_data = 3;
  for (int i = 0; i < this->player_data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->player_data(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* StandardizedSharedESP::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 sender_steamid = 1;
  if (has_sender_steamid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->sender_steamid(), target);
  }

  // required float message_send_time = 2;
  if (has_message_send_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->message_send_time(), target);
  }

  // repeated .SharedEspPlayerData player_data = 3;
  for (int i = 0; i < this->player_data_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->player_data(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int StandardizedSharedESP::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 sender_steamid = 1;
    if (has_sender_steamid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sender_steamid());
    }

    // required float message_send_time = 2;
    if (has_message_send_time()) {
      total_size += 1 + 4;
    }

  }
  // repeated .SharedEspPlayerData player_data = 3;
  total_size += 1 * this->player_data_size();
  for (int i = 0; i < this->player_data_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->player_data(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StandardizedSharedESP::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const StandardizedSharedESP* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const StandardizedSharedESP*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void StandardizedSharedESP::MergeFrom(const StandardizedSharedESP& from) {
  GOOGLE_CHECK_NE(&from, this);
  player_data_.MergeFrom(from.player_data_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sender_steamid()) {
      set_sender_steamid(from.sender_steamid());
    }
    if (from.has_message_send_time()) {
      set_message_send_time(from.message_send_time());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void StandardizedSharedESP::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StandardizedSharedESP::CopyFrom(const StandardizedSharedESP& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StandardizedSharedESP::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  for (int i = 0; i < player_data_size(); i++) {
    if (!this->player_data(i).IsInitialized()) return false;
  }
  return true;
}

void StandardizedSharedESP::Swap(StandardizedSharedESP* other) {
  if (other != this) {
    std::swap(sender_steamid_, other->sender_steamid_);
    std::swap(message_send_time_, other->message_send_time_);
    player_data_.Swap(&other->player_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata StandardizedSharedESP::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = StandardizedSharedESP_descriptor_;
  metadata.reflection = StandardizedSharedESP_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int StandardizedCheatInformation::kSenderSteamidFieldNumber;
const int StandardizedCheatInformation::kCheatNameFieldNumber;
#endif  // !_MSC_VER

StandardizedCheatInformation::StandardizedCheatInformation()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void StandardizedCheatInformation::InitAsDefaultInstance() {
}

StandardizedCheatInformation::StandardizedCheatInformation(const StandardizedCheatInformation& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void StandardizedCheatInformation::SharedCtor() {
  _cached_size_ = 0;
  sender_steamid_ = 0u;
  cheat_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StandardizedCheatInformation::~StandardizedCheatInformation() {
  SharedDtor();
}

void StandardizedCheatInformation::SharedDtor() {
  if (cheat_name_ != &::google::protobuf::internal::kEmptyString) {
    delete cheat_name_;
  }
  if (this != default_instance_) {
  }
}

void StandardizedCheatInformation::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StandardizedCheatInformation::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StandardizedCheatInformation_descriptor_;
}

const StandardizedCheatInformation& StandardizedCheatInformation::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CrossCheatTalkNetMessages_2eproto();
  return *default_instance_;
}

StandardizedCheatInformation* StandardizedCheatInformation::default_instance_ = NULL;

StandardizedCheatInformation* StandardizedCheatInformation::New() const {
  return new StandardizedCheatInformation;
}

void StandardizedCheatInformation::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    sender_steamid_ = 0u;
    if (has_cheat_name()) {
      if (cheat_name_ != &::google::protobuf::internal::kEmptyString) {
        cheat_name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool StandardizedCheatInformation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 sender_steamid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sender_steamid_)));
          set_has_sender_steamid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_cheat_name;
        break;
      }

      // optional string cheat_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_cheat_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_cheat_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->cheat_name().data(), this->cheat_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void StandardizedCheatInformation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 sender_steamid = 1;
  if (has_sender_steamid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->sender_steamid(), output);
  }

  // optional string cheat_name = 2;
  if (has_cheat_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->cheat_name().data(), this->cheat_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->cheat_name(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* StandardizedCheatInformation::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 sender_steamid = 1;
  if (has_sender_steamid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->sender_steamid(), target);
  }

  // optional string cheat_name = 2;
  if (has_cheat_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->cheat_name().data(), this->cheat_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->cheat_name(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int StandardizedCheatInformation::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 sender_steamid = 1;
    if (has_sender_steamid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sender_steamid());
    }

    // optional string cheat_name = 2;
    if (has_cheat_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->cheat_name());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StandardizedCheatInformation::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const StandardizedCheatInformation* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const StandardizedCheatInformation*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void StandardizedCheatInformation::MergeFrom(const StandardizedCheatInformation& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sender_steamid()) {
      set_sender_steamid(from.sender_steamid());
    }
    if (from.has_cheat_name()) {
      set_cheat_name(from.cheat_name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void StandardizedCheatInformation::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StandardizedCheatInformation::CopyFrom(const StandardizedCheatInformation& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StandardizedCheatInformation::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void StandardizedCheatInformation::Swap(StandardizedCheatInformation* other) {
  if (other != this) {
    std::swap(sender_steamid_, other->sender_steamid_);
    std::swap(cheat_name_, other->cheat_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata StandardizedCheatInformation::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = StandardizedCheatInformation_descriptor_;
  metadata.reflection = StandardizedCheatInformation_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
